\documentclass[11pt,spanish,listoffigures]{tfgetsinf}
\usepackage[utf8]{inputenc}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PORTADA %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Diseño e implementación de un proxy inverso para una arquitectura de microservicios}
\author{Alejandro Carrión Sanmartín}
\tutor{Patricio Letelier Torres}
\curs{2020-2021}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PALABRAS CLAVE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\keywords{????, ?????????} % Paraules clau
         {?????, ???} % Palabras clave
         {?????, ?????} % Key words

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% RESUMEN %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}[spanish]
????
\end{abstract}
\begin{abstract}[catalan]
????
\end{abstract}
\begin{abstract}[english]
????
\end{abstract}

\mainmatter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% INTRODUCCIÓN %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introducción}

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% MOTIVACIÓN %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\section{Motivación}

La automatización de los despliegues de programas, combinada o no con el uso de arquitecturas de microservicios, es una práctica en auge hoy en día en el mundo del desarrollo de software. Prácticas de DevOps tales como la entrega continua son cada vez más utilizadas con el fin de acortar tiempos en el ciclo de vida del desarrollo de sistemas y facilitar así su construcción, además de sistematizar los despliegues para poder llevarlos a cabo de manera sencilla.

Por otro lado, el uso de arquitecturas de microservicios ya está consolidado. Esto consiste en la construcción de servicios independientes, ejecutados en procesos diferentes, que se encargan de realizar funciones concretas y que trabajan de forma conjunta para lograr el objetivo u objetivos globales de la aplicación que constituyen. Los beneficios que otorga este enfoque frente a la aproximación tradicional monolítica son muchos y muy variados. Algunos de ellos son:

\begin{itemize}

	\item \textbf{Uso de diferentes tecnologías}. Cada microservicio puede estar construido con una tecnología diferente y puede utilizar, incluso, distintos mecanismos de persistencia.

	\item \textbf{Maniobrabilidad en los despliegues}. Ante cualquier cambio no es necesario desplegar la aplicación entera, solamente los microservicios implicados.

	\item \textbf{Tolerancia a fallos}. La posibilidad de desplegar la aplicación de forma que quede repartida en diferentes máquinas, además de poder tener más de una instancia del mismo microservicio, otorga cierta capacidad para tolerar fallos.

	\item \textbf{Escalabilidad y mantenibilidad}. Los microservicios, y la separación funcional que otorgan, facilitan el escalado de las diferentes partes de la aplicación de manera independiente. Lo mismo sucede con el mantenimiento, pudiéndose crear equipos especializados.

\end{itemize}

Se puede obtener más información acerca de los microservicios en el artículo de James Lewis y Martin Fowler titulado ''\emph{Microservices}'' \cite{LewisAndFowler}. Para una lectura con más profundidad, el libro ''\emph{Building Microservices}'' \cite{Newman} de Sam Newman.

Por contra, este tipo de arquitecturas aumentan la complejidad del desarrollo en algunos aspectos concretos como pueden ser el versionado de los microservicios o la coordinación de las comunicaciones entre ellos. A raíz de otra de sus desventajas surge este trabajo: la exposición de múltiples puntos de entrada al \emph{backend} formado por los microservicios. Para ello, se desarrollará un \emph{proxy} inverso que sea su puerta de acceso.

Para comprender correctamente que es un \emph{proxy} inverso es conveniente ver su relación con su patrón hermano: el \emph{proxy} de reenvío, o simplemente \emph{proxy}. Un \emph{proxy} es un componente intermediario que se encarga de proteger una red cliente haciendo que estos clientes no tengan comunicación directa con los servidores a los que se conectan a través de Internet. Por otro lado, un \emph{proxy} inverso hace la misma función pero protegiendo a un grupo de servidores, ocultándolos así de sus clientes. Ambos pueden coexistir, de hecho suelen hacerlo. Para ilustrar mejor esta diferencia, la figura \ref{proxyContraProxyInverso} presenta un esquema conceptual de un \emph{proxy} y otro de un \emph{proxy} inverso.

\begin{figure}[ht]
\centering
\includegraphics[width=0.49\textwidth]{imagenes/proxy}
\includegraphics[width=0.49\textwidth]{imagenes/proxyInverso}
\caption{Esquema de un \emph{proxy} frente a un \emph{proxy} inverso.}
	\label{proxyContraProxyInverso}
\end{figure}

El uso de un \emph{proxy} inverso no queda restringido a ciertas arquitecturas, pudiéndose utilizar para ocultar el servicio o servicios que consume cualquier aplicación. Sin embargo, este componente adquiere una gran importancia en el enfoque de microservicios, pues es importante no exponer estos al exterior. Además, se suele utilizar también para realizar tareas de balanceo de carga. La figura \ref{proxyInversoContraNoProxyInverso} muestra la comparativa de una arquitectura de microservicios básica y otra que utiliza un \emph{proxy} inverso. En la segunda se observa que, con el uso de un componente de este tipo, los clientes no acceden directamente a los microservicios, ni siquiera los conocen.

\begin{figure}[ht]
\centering
\includegraphics[width=0.49\textwidth]{imagenes/arquitecturaMicroserviciosBasica}
\includegraphics[width=0.49\textwidth]{imagenes/arquitecturaMicroserviciosConProxyInverso}
\caption{Arquitectura de microservicios básica frente a una con \emph{proxy} inverso.}
	\label{proxyInversoContraNoProxyInverso}
\end{figure}

La temática del presente trabajo es la implementación de un \emph{proxy} inverso que actúe de intermediario entre la interfaz de usuario de una aplicación en desarrollo y sus microservicios. Se pretende construir este nuevo componente porque se cree necesario proteger el \emph{backend} de la aplicación y ocultar los microservicios que lo forman. Por otro lado, también se quiere tener la posibilidad de lanzar a ejecución múltiples instancias de los microservicios con el fin de conseguir cierta tolerancia a fallos y poder también realizar balanceo de carga.

Este proyecto surge en el contexto de una práctica en empresa. El autor ha tenido la oportunidad de formar parte del equipo de I+D+i de una empresa de desarrollo de software enfocada al sector sociosanitario, durante un periodo de tiempo de más de un año. Esta empresa comercializa un software de gestión geriátrica y actualmente está desarrollando la nueva versión de su producto, utilizando enfoques y tecnologías de vanguardia. Entre ellos: arquitecturas de microservicios, desarrollo de software dirigido por modelos y generación automática de código.

La temática comentada fue elegida debido a la estrecha relación que guarda con el desempeño del autor en las prácticas mencionadas, esto es, contribuciones a un microservicio específico destinado a orquestar el despliegue de la aplicación. Por otro lado, el desarrollo a llevar a cabo le va a otorgar una visión más global de la aplicación sobre la que se trabaja, así como aumentar el nivel de conocimiento acerca de la misma, con la motivación de seguir contribuyendo al proyecto por mucho tiempo más. Por último, la tecnología a utilizar, .NET, es de su interés y aspira así a crecer como desarrollador de ese \emph{framework}.

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% OBJETIVOS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\section{Objetivos}

El objetivo principal de este trabajo es construir un \emph{proxy} inverso para una aplicación con arquitectura de microservicios. La construcción de este tiene las siguientes aspiraciones sobre el producto en construcción:

\begin{itemize}

	\item \textbf{Ocultar los microservicios} que forman la aplicación para que la interfaz de usuario no acceda directamente a ellos por motivos de seguridad.

	\item Permitir \textbf{múltiples instancias} en ejecución de los microservicios que, a su vez, tiene por finalidad:

	\begin{itemize}

		\item Conseguir que la aplicación sea \textbf{tolerante a fallos}, gracias a la posibilidad de tener un mismo microservicio desplegado en máquinas diferentes.

		\item \textbf{Aumentar la eficiencia}, al poder crear o parar instancias dinámicamente según el tráfico que reciba la aplicación.

	\end{itemize}

\end{itemize}

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ESTRUCTURA DEL DOCUMENTO %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\section{Estructura del documento}

Este documento se divide en X grandes bloques...

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ESTADO DEL ARTE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Estado del arte}

En la actualidad existen en el mercado muchas aplicaciones y servicios que se pueden utilizar como \emph{proxy} inverso. Algunas de estas soluciones son de pago, otras gratuitas e incluso algunas de código abierto. Se pueden dividir en dos tipos: productos \emph{software} ya construidos y librerías. Los primeros suelen ser fáciles de configurar y se pueden poner en marcha de una manera muy rápida. Las segundas requieren una parte de programación pero se adaptan mejor a las necesidades particulares, pues permiten tener más control al usuario. A continuación se van a comentar dos herramientas de cada tipo, una de las cuales será la tecnología utilizada. También se mostrará un ejemplo básico de uso de esta.

Cabe destacar que no hay muchos servicios que se dediquen exclusivamente a funcionar como \emph{proxy} inverso. Estos suelen ofrecer otros productos como servidores web o balanceadores de carga. Por otro lado, lo habitual es hacer uso de un producto ya hecho, por lo que tampoco es fácil encontrar librerías que permitan personalizar un \emph{proxy} inverso, menos aún si hay que tener en cuenta la tecnología que se utiliza. En relación con esto, las librerías elegidas son para el lenguaje de programación C\#, utilizado en el resto de la aplicación de la que forma parte el \emph{proxy} inverso.

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% API GATEWAY %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\section{Patrón API \emph{Gateway}}

A modo de aparte, es interesante mencionar un patrón parecido al \emph{proxy} inverso y que también podría haber sido utilizado para resolver el problema que atañe a este trabajo: el API \emph{Gateway}. Ambos comparten algunos casos de uso, por lo que sus diferencias causan confusión y no suelen quedar claras.

Generalmente, se entiende que un API \emph{Gateway} es una especialización de un \emph{proxy} inverso, proporcionando así funcionalidades extra. Las más aceptadas e importantes son:

\begin{itemize}

	\item Interpretan los mensajes que reciben y pueden hacer transformaciones sobre ellos, mientras que los \emph{proxy} inversos solo los redirigen donde corresponda.
	
	\item Suelen ofrecer agregaciones de peticiones, esto es, aunar dos o más llamadas al \emph{backend} y exponer esta composición a través de un único \emph{endpoint}.
	
	\item Realizan tareas transversales a todos los \emph{endpoints} como autenticación, autorización o monitorización.

\end{itemize}

El patrón recién comentado fue descartado desde el primer momento porque no se quería tener la funcionalidad de ninguno de los tres puntos clave que caracterizan esta aproximación. Por este motivo, y por la búsqueda de sencillez, era más coherente decantarse por un \emph{proxy} inverso.

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PRODUCTOS HECHOS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\section{Productos}

		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% NGINX %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		\subsection{NGINX}

Originariamente NGINX \cite{NGINX} fue construido para ser un servidor web pero más tarde ofreció la posibilidad de actuar como \emph{proxy} inverso, balanceador de carga o \emph{proxy} para protocolos de correo electrónico. Desde la vertiente que interesa a este trabajo:

\begin{itemize}

	\item Se trata de un \emph{proxy} inverso ligero y de alto rendimiento.

	\item Ofrece una versión gratuita y otra de pago, NGINX Plus, la cual ofrece funcionalidades extra.

	\item Se configura a través de un fichero el cual puede ser recargado durante su ejecución, es decir, se puede configurar dinámicamente.

\end{itemize}

		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% APACHE HTTPD %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		\subsection{Apache HTTPD}

Apache HTTPD \cite{Apache}. Además de ser un servidor web "básico", y proveer contenido estático y dinámico a los usuarios finales, Apache HTTPD puede también actuar como proxy inverso

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LIBRERÍAS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\section{Librerías}

		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% YARP %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		\subsection{YARP}

YARP \cite{YARP} es una librería hecha por el propio Microsoft \cite{Microsoft} y su objetivo es facilitar la creación de \emph{proxy} inversos. Surgió dentro de la propia infraestructura de la empresa, en la que diferentes equipos preguntaban si existía algún producto de este tipo disponible para utilizar en sus respectivos proyectos. La respuesta de la compañía fue crear un equipo especializado para construir esta librería y así estandarizar su uso. Además, se decidió hacer pública tanto su existencia como su código, siendo así una opción \emph{open source} a tener en cuenta.

Se encuentra todavía en desarrollo, habiendo sido lanzada su primera \emph{release} el 25 de Junio de 2020, y, a fecha de este trabajo, todavía solo se puede utilizar una \emph{preview}. Se prevé que vayan saliendo a la luz más versiones con más funcionalidades basadas en la experiencia de la propia empresa pero también en las opiniones de los usuarios externos. YARP es compatible con .NET Core 3.1 y .NET 5 pero algunas funcionalidades solo están disponibles para el segundo \emph{framework}, ya que se trata de la generación inmediatamente más moderna.

A raíz de la heterogeneidad de casos de uso que debe cubrir para satisfacer las necesidades de los diferentes equipos de Microsoft, está diseñada para ser muy personalizable y flexible. Otro aspecto importante es que permite cambiar la configuración del \emph{proxy} inverso de forma dinámica, lo que no obliga a tener que volver a lanzarlo a ejecución cuando se añada una nueva ruta, por ejemplo.

Permite construir \emph{proxy} inversos de nivel 7. Esto hace referencia a la capa del Modelo OSI (figura \ref{modeloOSI}) sobre la que actúan, la de aplicación en este caso. Gracias a esto, es posible modificar una petición HTTP antes de redirigirla, como por ejemplo sus \emph{headers} o ruta de destino. Sin embargo, no se puede hacer lo mismo con su contenido, ni siquiera es interpretado para tardar el menor tiempo posible en redirigir las peticiones. Además, no es un componente aparte sino que se integra con la \emph{pipeline} de \emph{middlewares} de .NET \cite{MiddlewaresPipeline}, haciendo que su eficiencia sea muy alta.

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{imagenes/modeloOSI}
\caption{Modelo OSI.}
	\label{modeloOSI}
\end{figure}

Por último, la documentación propia no es corta pero tampoco excesiva. Asimismo, su corta edad hace que no se encuentren referencias o ejemplos de código de la comunidad fácilmente. Tampoco problemas planteados con sus posibles soluciones.

		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% OCELOT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		\subsection{Ocelot}
		
Ocelot \cite{Ocelot} es una librería para .NET Core que permite a una aplicación de ese \emph{framework} actuar como API \emph{Gateway}. Posee las características siguientes:

\begin{itemize}

	\item Está pensada para arquitecturas orientadas a servicios o a microservicios.
	
	\item Al tratarse de una librería, se utiliza de forma sencilla añadiéndola como un paquete NuGet más.
	
	\item Su configuración es muy básica, teniendo que especificarla en un fichero Json.
	
	\item No permite cambiar su configuración de manera dinámica.

\end{itemize}

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% COMPARATIVA %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\section{Comparativa}

Precio, API Gateway, Reverse proxy, documentación, comunidad, previa configuración, cantidad de posible configuración, extensibilidad, recarga de configuración dinámica.

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% TECNOLOGÍA UTILIZADA %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\section{Tecnología utilizada}

Primero de todo, la tecnología utilizada es .NET, más concreto, el lenguaje de programación C\# y el entorno de desarrollo habitual para él, Visual Studio, en la versión del 2019. Como se comenta en la introducción de este capítulo, la aplicación en la cual se incluye el \emph{proxy} inverso está construida con ese \emph{framework}, por lo que se quiso mantener ese aspecto también en el nuevo componente. Este aspecto corresponde al requisito no funcional RNF03, que se verá en el apartado \ref{requisitosNoFuncionales}.

Por otro lado, se ha decidido utilizar YARP para construir el \emph{proxy} inverso. La aplicación sobre la que se trabaja posee un mecanismo de despliegue automático muy 
particular, por lo que la flexibilidad y capacidad de adaptación que ofrece esta librería son muy adecuadas para integrar el \emph{proxy} inverso con dicho proceso. Si se hubiera utilizado un producto ya hecho, no se hubiera podido conseguir un nivel alto de cohesión y se hubieran tenido que abordar problemas de integración. Por otro lado, su sencillez y altas prestaciones hacen que destaque frente a Ocelot, la que, como ya se ha comentado, permite crear API \emph{Gateways}.

Por último, se ha utilizado Postman \cite{Postman} para realizar consultas de prueba al \emph{proxy} inverso y comprobar su funcionamiento. Postman es una herramienta gratuita que permite hacer justo lo que se ha descrito. Se trata de un cliente para peticiones HTTP REST que se utiliza para probar de manera sencilla servicios web y así agilizar su desarrollo.

		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% EJEMPLO DE USO BÁSICO %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		\subsection{Ejemplo de uso básico} \label{ejemploUsoYARP}

Una vez comentada la elección que finalmente se hizo y el porqué, se va a introducir un ejemplo de uso básico de YARP para dar una visión general de lo que es capaz de hacer esta librería. De este modo, también será más fácil comprender el funcionamiento del \emph{proxy} inverso desarrollado.

En lineas generales, empezar a utilizar Yarp no es nada difícil, en un par de horas se puede llegar a tener un \emph{proxy} inverso básico funcionando. Si bien, es más complejo utilizar características avanzadas o personalizarlo en función de las necesidades particulares.

La demostración que se va a realizar consiste en crear un \emph{proxy} inverso que redirija peticiones hacía dos servicios web de prueba, creados anteriormente para el ejemplo. Estos simulan ser un servicio de localización y devuelven siempre ''\emph{Valencia, Spain}''. También muestran este mismo mensaje por consola cuando son consultados para poder visualizar a través de ella la cantidad de peticiones que responden.

Para empezar con el ejemplo, se crea un proyecto web vacío de .NET. Una vez el proyecto se ha creado, hay que añadir la referencia a la librería de YARP. En .NET las librerías se añaden como paquete NuGet \cite{NuGet} y para buscar qué paquetes hay disponibles e instalarlos se puede utilizar un asistente gráfico, figura \ref{ejemploYARP_instalacionNuGet}.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{imagenes/ejemploYARP/instalacionNuGet}
\caption{Instalación del NuGet de YARP.}
	\label{ejemploYARP_instalacionNuGet}
\end{figure}

Acto seguido, es necesario añadir un poco de código para poner en marcha un \emph{proxy} inverso sencillo. En la clase \emph{Startup} hay que modificar los métodos por defecto \emph{ConfigureServices} y \emph{Configure}. En el primero de ellos es necesario registrar el código del \emph{proxy} inverso, haciendo \emph{services.AddReverseProxy()}, y cargar la configuración de las rutas, \emph{proxyBuilder.LoadFromConfig()}. En el segundo basta con asegurarse de que se haga la llamada \emph{app.UseRouting()} y añadir  \emph{endpoints.MapReverseProxy()} dentro del \emph{UseEndpoint}. Para visualizar mejor estos cambios, figura \ref{ejemploYARP_startup}.

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{imagenes/ejemploYARP/startup}
\caption{Clase \emph{Startup} después de añadir el código del \emph{proxy} inverso.}
	\label{ejemploYARP_startup}
\end{figure}

Por otro lado, hay que configurar las rutas que va a tener el \emph{proxy} inverso, es decir, los enrutamientos que debe hacer en tiempo de ejecución. Para ello se necesita especificar dichas rutas en el archivo \emph{appsettings.json}. Este archivo se utiliza para especificar cualquier tipo de configuración y se podría haber utilizado otro diferente. También se puede configurar a través de código pero requiere algo más de trabajo. Por este motivo, en esta demostración se va a utilizar el primer método, ya que se pretende mostrar un ejemplo lo más simple posible.

La figura \ref{ejemploYARP_appsettings} muestra las rutas creadas para esta prueba. Se ha creado un par ruta-\emph{cluster} con dos destinaciones. Para no entrar en mucho detalle, lo que es importante es que la ruta tiene un patrón \emph{\{**catch-all\}}, para capturar todas las peticiones, y el \emph{cluster} contiene dos destinaciones, una por cada servicio de localización, comentados al principio de este apartado. Lo que se pretende conseguir con esta configuración es que el \emph{proxy} inverso capture todas las peticiones y las envíe de manera aleatoria a cualquiera de los dos servicios.

\begin{figure}[ht]
\centering
\includegraphics[width=0.5\textwidth]{imagenes/ejemploYARP/appsettings}
\caption{Fichero \emph{appsettings.json} con la configuración de las rutas para el \emph{proxy} inverso.}
	\label{ejemploYARP_appsettings}
\end{figure}

Lo siguiente es preparar los servicios para una prueba rápida. En la figura \ref{ejemploYARP_servicios_preparacion} se observa el escenario inicial. En la parte superior se encuentra el \emph{proxy} inverso creado y, en la inferior, los dos servicios de localización . Importante destacar que los puertos de estos últimos coinciden con lo que se han indicado en el \emph{appsettings.json}.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{imagenes/ejemploYARP/servicios_preparacion}
\caption{Escenario inicial de prueba de YARP con los servicios preparados.}
	\label{ejemploYARP_servicios_preparacion}
\end{figure}

Para simular una petición de un cliente se va a realizar una consulta con Postman. Esta estará dirigida al \emph{proxy} inverso y deberá ser redirigida a alguno de los dos servicios de localización, como se ha indicado en el \emph{appsettings.json}. En la figura \ref{ejemploYARP_servicios_funcionando}, se muestra el escenario anterior tras ejecutar la petición Postman repetidas veces. Se observa que el \emph{proxy} inverso la ha redirigido de manera aleatoria entre los dos otros servicios. En la consola del \emph{proxy} inverso es interesante ver el mensaje por defecto que muestra YARP indicando hacia qué dirección redirige cada petición.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{imagenes/ejemploYARP/servicios_funcionando}
\caption{Escenario de prueba de YARP con los servicios después de realizar algunas consultas.}
	\label{ejemploYARP_servicios_funcionando}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% DESARROLLO DE LA SOLUCIÓN %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Desarrollo de la solución}

????? Este capítulo alberga el grueso del trabajo. En él...

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ESPECIFICACIÓN DE REQUISITOS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\section{Especificación de requisitos} \label{especificacionRequisitos}

La especificación de requisitos del \emph{proxy} inverso se ha llevado a cabo elaborando los casos de uso que debe cubrir. Adicionalmente a estos, también se expondrán una serie de requisitos funcionales y no funcionales que el producto debe satisfacer.

		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CASOS DE USO %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		\subsection{Casos de uso} \label{casosDeUso}

Los casos de uso van a ser expuestos a continuación con un diagrama de casos de uso, figura \ref{diagramaCasosDeUso}, y en formato de tabla, indicando para cada uno de ellos un identificador, un nombre, el actor que lo lleva a cabo y una breve descripción:

\begin{figure}[ht]
\centering
\includegraphics[width=0.52\textwidth]{imagenes/diagramaCasosDeUso}
\caption{Diagrama de casos de uso del \emph{proxy} inverso.}
	\label{diagramaCasosDeUso}
\end{figure}

\begin{center} \begin{tabular}{| l | p{11.3cm} |}
\hline
\textbf{Identificador} & CU01
\\ \hline
\textbf{Nombre} & Añadir rutas
\\ \hline
\textbf{Actor} & Microservicio encargado de orquestar el despliegue
\\ \hline
\textbf{Descripción} & El microservicio que organiza los despliegues de la aplicación le indica al \emph{proxy} inverso unas rutas para que las tenga en cuenta a la hora de redirigir peticiones, CU03. Las rutas son descritas mediante la ruta base de las peticiones que tiene que capturar y la dirección a la que redirigirlas.
\\ \hline \end{tabular} \end{center}

\begin{center} \begin{tabular}{| l | p{11.3cm} |}
\hline
\textbf{Identificador} & CU02
\\ \hline
\textbf{Nombre} & Eliminar rutas
\\ \hline
\textbf{Actor} & Microservicio encargado de orquestar el despliegue
\\ \hline
\textbf{Descripción} & El microservicio que organiza los despliegues de la aplicación le indica al \emph{proxy} inverso unas rutas para que las deje de tener en cuenta a la hora de redirigir peticiones, CU03. Las rutas son descritas mediante la ruta base de las peticiones que tiene que dejar de capturar y la dirección a la que no redirigir más peticiones.
\\ \hline \end{tabular} \end{center}

\begin{center} \begin{tabular}{| l | p{11.3cm} |}
\hline
\textbf{Identificador} & CU03
\\ \hline
\textbf{Nombre} & Enrutamiento
\\ \hline
\textbf{Actor} & Interfaz de usuario / Microservicio X
\\ \hline
\textbf{Descripción} & La interfaz de usuario o cualquier microservicio de la aplicación envía una petición a la dirección en la que escucha el \emph{proxy} inverso y esta es capturada y redirigida hacia un \emph{endpoint} especificado por una determinada ruta. Las rutas determinan qué peticiones tienen que ser encaminadas a qué direcciones. Es necesario cargar previamente la ruta correspondiente mediante el caso de uso CU01.
\\ \hline \end{tabular} \end{center}

		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% REQUISITOS FUNCIONALES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		\subsection{Requisitos funcionales} \label{requisitosFuncionales}

El \emph{proxy} inverso ha de cumplir una serie de requisitos funcionales, o características concretas, que no son propiamente casos de uso pero que se considera de interés mencionarlos, pues son relevantes para su funcionalidad. Los requisitos funcionales se centran en lo que debe hacer el sistema y dejan de lado la interacción con el usuario. Complementan así los casos de uso y ayudan también a comprender qué debe hacer exactamente el producto. Cabe destacar que estos aspectos se podrían haber presentado de forma conjunta a los casos de uso pero se cree que de esta manera quedan más claras, por un lado, las tres funcionalidades básicas y, por otro lado, algunos detalles más concretos.

Estos requisitos van a ser representados mediante un identificador, un nombre, el caso de uso con el que guardan relación, y una breve descripción:

\begin{center} \begin{tabular}{| l | p{9.5cm} |}
\hline
\textbf{Identificador} & RF01
\\ \hline
\textbf{Nombre} & Carga de rutas dinámica
\\ \hline
\textbf{Caso de uso relacionado} & CU01
\\ \hline
\textbf{Descripción} & La acción de añadir rutas a las que redirigir peticiones se debe poder hacer de manera dinámica, es decir, durante la propia ejecución. Esto permite no tener que parar y volver a lanzar el \emph{proxy} inverso cada vez que se añaden o eliminan rutas. Esta es una característica bastante importante ya que el tiempo en el que se reinicia no estaría atendiendo peticiones y estas fallarían, quedando el sistema inaccesible durante ese tiempo.
\\ \hline \end{tabular} \end{center}

\begin{center} \begin{tabular}{| l | p{9.5cm} |}
\hline
\textbf{Identificador} & RF02
\\ \hline
\textbf{Nombre} & Doble comunicación
\\ \hline
\textbf{Caso de uso relacionado} & CU03
\\ \hline
\textbf{Descripción} & El \emph{proxy} inverso tiene que estar preparado para servir de puerta de entrada al \emph{backend} desde la interfaz de usuario pero también debe interconectar los microservicios que forman dicho \emph{backend}. De esta forma, todas las peticiones que se lleven a cabo desde fuera o dentro del propio sistema deben pasar por él.
\\ \hline \end{tabular} \end{center}

\begin{center} \begin{tabular}{| l | p{9.5cm} |}
\hline
\textbf{Identificador} & RF03
\\ \hline
\textbf{Nombre} & Multiinstancia de microservicios
\\ \hline
\textbf{Caso de uso relacionado} & CU01, CU02 y CU03
\\ \hline
\textbf{Descripción} & Se debe soportar la ejecución simultánea de más de una instancia de un mismo microservicio, es decir, el \emph{proxy} inverso debe ser capaz de permitir la existencia de más de una dirección que atienda un mismo grupo de peticiones.
\\ \hline \end{tabular} \end{center}

\begin{center} \begin{tabular}{| l | p{9.5cm} |}
\hline
\textbf{Identificador} & RF04
\\ \hline
\textbf{Nombre} & Balanceo de carga
\\ \hline
\textbf{Caso de uso relacionado} & CU03
\\ \hline
\textbf{Descripción} & En relación con el RF03, las peticiones deben ser redirigidas de manera inteligente hacía las distintas direcciones posibles, si las hay, para una determinada ruta. En concreto, se busca no inundar de peticiones unas y dejar en el olvido otras.
\\ \hline \end{tabular} \end{center}

\begin{center} \begin{tabular}{| l | p{9.5cm} |}
\hline
\textbf{Identificador} & RF05
\\ \hline
\textbf{Nombre} & Versionado de microservicios
\\ \hline
\textbf{Caso de uso relacionado} & CU01, CU02 y CU03
\\ \hline
\textbf{Descripción} & Relacionado con el RF03, las diferentes instancias de un mismo microservicio pueden corresponder a versiones diferentes del mismo. De esta forma, las peticiones deberán ser redirigidas a una dirección u otra en función de la versión del microservicio que se quiera utilizar.
\\ \hline \end{tabular} \end{center}

\begin{center} \begin{tabular}{| l | p{9.5cm} |}
\hline
\textbf{Identificador} & RF06
\\ \hline
\textbf{Nombre} & Multiinstancia de \emph{proxy} inversos
\\ \hline
\textbf{Caso de uso relacionado} & CU03
\\ \hline
\textbf{Descripción} & Se debe poder trabajar con más de un \emph{proxy} inverso a la vez, de manera que uno enrute una petición hacía otro \emph{proxy} inverso y este segundo la enrute hacía el microservicio final. Este paso por más de un enrutador debe ser transparente para ellos, siendo su única función la de redirigir las peticiones.
\\ \hline \end{tabular} \end{center}

\begin{center} \begin{tabular}{| l | p{9.5cm} |}
\hline
\textbf{Identificador} & RF07
\\ \hline
\textbf{Nombre} & Instancias exclusivas
\\ \hline
\textbf{Caso de uso relacionado} & CU03
\\ \hline
\textbf{Descripción} & Derivado del RF06, debe ser posible desplegar un \emph{proxy} inverso que solo se encargue de las peticiones que vienen de la interfaz de usuario y otro para las que van de un microservicio a otro, pudiéndose aumentar el número de estos.
\\ \hline \end{tabular} \end{center}

		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% REQUISITOS NO FUNCIONALES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		\subsection{Requisitos no funcionales} \label{requisitosNoFuncionales}
		
Un requisito no funcional se entiende como una restricción impuesta sobre un producto \emph{software} que no corresponde a una funcionalidad del mismo. Están directamente relacionados con la calidad que tendrá el producto en cuestión y pueden referirse a características de diferentes tipos tales como fiabilidad o usabilidad. En concreto, la ISO/IEC 25010 \cite{ISO25010}, comúnmente llamada SQuaRE (\emph{System and software Quality Requirements and Evaluation}), define ocho características principales y algunas subcaracterísticas específicas para cada una. La figura \ref{iso25010} las muestra todas.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{imagenes/iso25010}
\caption[Características y subcaracterísticas de calidad de un producto \emph{software} definidas en la ISO/IEC 25010.]{Características y subcaracterísticas de calidad de un producto \emph{software} definidas en la ISO/IEC 25010. Imagen de \url{https://iso25000.com/index.php/normas-iso-25000/iso-25010}.}
	\label{iso25010}
\end{figure}

Sobre el \emph{proxy} inverso que atañe a este trabajo se imponen los siguientes requisitos no funcionales. Se detallan mediante un identificador, un nombre, la característica de la ISO a la que hacen referencia, una breve descripción y el motivo por el cual se considera necesario satisfacerlos:

\begin{center} \begin{tabular}{| l | p{11.3cm} |}
\hline
\textbf{Identificador} & RNF01
\\ \hline
\textbf{Nombre} & Autenticación de peticiones
\\ \hline
\textbf{Característica} & Seguridad
\\ \hline
\textbf{Descripción} & Se debe tener un sistema de autenticación que no permita escuchar ni redirigir peticiones sin autenticar. No se puede llevar a cabo ninguno de los tres casos de uso (CU01, CU02 y CU03) sin una previa autenticación.
\\ \hline
\textbf{Motivación} & Impedir que peticiones ajenas puedan ser atendidas y/o redirigidas para evitar posibles ataques.
\\ \hline \end{tabular} \end{center}

\begin{center} \begin{tabular}{| l | p{11.3cm} |}
\hline
\textbf{Identificador} & RNF02
\\ \hline
\textbf{Nombre} & Enrutamiento eficaz
\\ \hline
\textbf{Característica} & Eficiencia de desempeño
\\ \hline
\textbf{Descripción} & El enrutamiento, CU03, no debe ralentizar las peticiones en exceso de forma que las peticiones enrutadas no tomen un tiempo superior al 115\% del tiempo que tardaría la petición si no pasara por el \emph{proxy} inverso.
\\ \hline
\textbf{Motivación} & Evitar que el \emph{proxy} inverso suponga un retardo elevado en el tiempo de respuesta de las peticiones.
\\ \hline \end{tabular} \end{center}

\begin{center} \begin{tabular}{| l | p{11.3cm} |}
\hline
\textbf{Identificador} & RNF03
\\ \hline
\textbf{Nombre} & Tecnología impuesta
\\ \hline
\textbf{Característica} & Mantenibilidad
\\ \hline
\textbf{Descripción} & La tecnología a utilizar para llevar a cabo el proyecto tiene que ser .NET, con C\# como lenguaje de programación.
\\ \hline
\textbf{Motivación} & Guardar coherencia con el resto de los microservicios para poder ser mantenido por personas que hayan trabajado con otros de ellos anteriormente.
\\ \hline \end{tabular} \end{center}

\begin{center} \begin{tabular}{| l | p{11.3cm} |}
\hline
\textbf{Identificador} & RNF04
\\ \hline
\textbf{Nombre} & Estructura del proyecto
\\ \hline
\textbf{Característica} & Mantenibilidad
\\ \hline
\textbf{Descripción} & La estructura de carpetas y clases del proyecto debe ser similar a la de los demás microservicios, entendiéndose similar como aquella que pueda ser comprendida por una persona familiarizada con la estructura de referencia en un periodo de tiempo de 10 minutos como máximo.
\\ \hline
\textbf{Motivación} & Ídem RNF03: guardar coherencia con el resto de los microservicios para poder ser mantenido por personas que hayan trabajado con otros de ellos anteriormente.
\\ \hline \end{tabular} \end{center}

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% DISEÑO %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\section{Diseño}

En lo que se refiere al diseño de la solución, se va presentar su estructura final. Por otro lado, también se cree conveniente comentar los \emph{middlewares} que forman la \emph{pipeline} de YARP para ver qué componentes personalizados han sido desarrollados y añadidos.

		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ESTRUCTURA DE LA SOLUCIÓN %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		\subsection{Estructura de la solución}

En el apartado \ref{requisitosNoFuncionales}, el requisito no funcional RNF04 impone que la estructura del \emph{proxy} inverso debe ser similar a la del resto de microservicios. Por este motivo, la estructura del producto final sigue esa referencia, que pasa a detallarse a continuación.

Un microservicio cualquiera de esta aplicación, y el \emph{proxy} inverso en particular, tiene una arquitectura autogenerada de 8 capas:

\begin{itemize}

	\item \textbf{Dominio}. En ella se encuentran las entidades que representan el dominio de la aplicación. Estas son creadas en base a su previo modelado.

	\item \textbf{Contratos}. Principalmente contiene los DTOs, u objetos para la transferencia de datos. Son objetos que representan las entidades de dominio que utiliza el sistema internamente con la intención de no darlas a conocer directamente. De esta forma, se ofrece la información que se quiere y se puede ocultar o modificar parte de ella. Además, esta capa también contiene las interfaces de las acciones del backend que se invocan a través de la capa de proxy.

	\item \textbf{Persistencia}. Es la capa que se encarga de acceder y realizar las operaciones relacionadas con la base datos. El \emph{proxy} inverso no necesita persistir nada por lo que esta capa no existe en este caso.

	\item \textbf{Lógica}. Esta capa contiene la lógica de negocio. Al igual que la entidades de dominio, las acciones que representan la lógica han de ser modeladas. No solo incluye código autogenerado sino que las acciones son programadas aquí también.

	\item \textbf{Aplicación}. Se encarga de dar soporte a las operaciones CRUD (\emph{create}, \emph{read}, \emph{update} y \emph{delete}). También comprueba los permisos del usuario sobre la acción que se quiere realizar.

	\item \textbf{Servicios}. Representa el punto de entrada al microservicio. Define las acciones HTTP que expone el servicio a través de controladores.

	\item \textbf{\emph{Proxy}}. Contiene el código necesario para invocar las acciones del backend, expuestas en la capa de servicios. Esta capa es utilizada desde la interfaz de usuario para realizar peticiones al microservicio o cuando un microservicio se comunica con otro.

	\item \textbf{Referencias externas}. Se encarga de registrar los \emph{proxies} que se van a consumir para abstraer estas dependencias y así poder solucionar problemas de dependencias cíclicas.

\end{itemize}

Tras comentar las capas que forman la arquitectura del \emph{proxy} inverso, se muestra en la figura \ref{arquitectura} un esquema de cómo interactúan entre ellas.

% TODO: Añadir flecha Referencias externas hacia Proxy.

\begin{figure}[ht]
\centering
\includegraphics[width=0.55\textwidth]{imagenes/arquitectura}
\caption{Esquema de las capas de la arquitectura del \emph{proxy} inverso.}
	\label{arquitectura}
\end{figure}

			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CAPA DE LÓGICA %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

			\subsubsection{Capa de lógica}

Por otro lado, cabe destacar que la capa que más ha sido necesario modificar ha sido la de lógica, pues las acciones del \emph{proxy} inverso se implementan en ella. Es por esto que se va a entrar en más detalla acerca de esta capa. Las figuras \ref{proyectoLogica} y \ref{proyectoTestsLogica} muestran la estructura de carpetas y clases que forman los proyectos de la capa de lógica y sus pruebas, respectivamente. No todas las clases pero sí las más importantes serán comentadas a continuación.

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{imagenes/proyectoLogica}
\caption{Proyecto de Visual Studio de la capa de lógica.}
	\label{proyectoLogica}
\end{figure}

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\textwidth]{imagenes/proyectoTestsLogica}
\caption{Proyecto de Visual Studio de pruebas para la capa de lógica.}
	\label{proyectoTestsLogica}
\end{figure}

En el proyecto de lógica de la figura \ref{proyectoLogica} son reseñables los siguientes aspectos:

\begin{itemize}

	\item La carpeta \emph{Configuration} contiene clases que se encargan de procesar y llevar a cabo los cambios de configuración de rutas de manera dinámica. Se comunican así con las interfaces definidas por YARP para ello.

	\item La clase \emph{RoutesLoaderHostedService} se encarga de realizar una carga inicial de rutas predefinidas, esto es, cuando se inicia el microservicio.

	\item El \emph{RoutesLogicManager} implementa las acciones propias del \emph{reverse} proxy, es decir, las acciones de añadir y eliminar rutas.

	\item La carpeta llamada \emph{Middlewares} contiene los \emph{middlewares} creados que se añaden a la \emph{pipeline} de YARP. Se profundiza en esto en el siguiente apartado, \ref{pipelineYARP}.

	\item La clase \emph{RoutesUtils} extrae métodos de ayuda que se utilizan de forma repetida tales como la creación de identificadores de manera idempotente.

\end{itemize}

En el proyecto de pruebas (\ref{proyectoTestsLogica}) simplemente destacar la existencia de tres clases de prueba principales: \emph{AddNewRoutesTests}, \emph{RemoveRoutesTests} y \emph{RoutesUtilsTests}. La primera es para la acción de añadir rutas, la segunda para la de eliminarlas y la tercera para la clase \emph{RoutesUtils}. Por último, la clase \emph{LogicTestUtilities} incluye métodos auxiliares para realizar comprobaciones que se repiten en más de una prueba, como por ejemplo la comprobación de si una determinada ruta existe.

		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PIPELINE DE YARP %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		\subsection{\emph{Pipeline} de YARP} \label{pipelineYARP}

Una \emph{pipeline} se entiende como una sucesión de procesos que se ejecutan en cadena de manera que la salida de cada uno de ellos se conecta con la entrada del siguiente. Para gestionar las peticiones, .NET define una de ellas en el método \emph{Configure} \cite{MiddlewaresPipeline}. Está formada por componentes llamados \emph{middlewares}, con un determinado propósito cada uno de ellos. Los \emph{middlewares} disponibles cubren aspectos tales como páginas de excepciones especiales para el desarrollador, control de excepciones o seguridad de transporte.

Por su parte, YARP tiene una propia, integrada en la de .NET. Por defecto, sus \emph{middlewares} se encargan de realizar sesión de afinidad para las peticiones, balanceo de carga, \emph{health checks} pasivos y el enrutamiento final. Sin embargo, se puede personalizar añadiendo nuevos \emph{middlewares} hechos desde cero según la necesidad del desarrollador. La figura \ref{pipelineYARP_imagen} muestra como ha quedado configurada esta última en el \emph{proxy} inverso. En ella, se observa que se han utilizado los siguientes \emph{middlewares}:

\begin{figure}[ht]
\centering
\includegraphics[width=0.6\textwidth]{imagenes/pipelineYARP}
\caption{\emph{Pipeline} de YARP configurada para el \emph{proxy} inverso.}
	\label{pipelineYARP_imagen}
\end{figure}

\begin{itemize}

	\item \textbf{\emph{CustomProxyLog}}. Se encarga de personalizar los mensajes de \emph{log} que muestra el \emph{proxy} inverso por consola cuando enruta una petición. YARP muestra por defecto un mensaje pero se considera interesante mostrar más información para facilitar las tareas de depuración, por ejemplo.

	\item \textbf{\emph{SameMachineFilter}}. Su finalidad es filtrar las posibles destinaciones del enrutamiento de una petición de forma que si una de las direcciones corresponde a la misma máquina en la que se encuentra el \emph{proxy} inverso, sea redirigida hacía ella. Esto puede suceder cuando el microservicio destino se encuentra desplegado en la misma máquina. De esta manera se ahorra tiempo evitando hacer una petición a otra dirección.

	\item \textbf{\emph{ProxyLoadBalancing}}. No es un \emph{middleware} creado para este proyecto, se trata de uno predefinido por YARP que se encarga de realizar las tareas de balanceo de carga cuando una misma ruta tiene diferentes posibles destinaciones. En concreto, elige una entre las disponibles en base a un algoritmo que se puede configurar.

\end{itemize}

Por último, la figura (TODO:Añadir figura) muestra un esquema de los \emph{middlewares} utilizados para ilustrar mejor el flujo de una petición al pasar por ellos.

%TODO: Añadir esquema del orden de los middleware de la pipeline de YARP.

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% METODOLOGÍA %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\section{Metodología} \label{metodologia}

Para llevar a cabo este desarrollo no se ha seguido ninguna metodología concreta, ni tradicional ni ágil. No obstante, se ha optado por la vía ágil en el sentido de que se han seguido algunas de las prácticas propuestas por varias de estas metodologías, tales como Scrum o Kanban, con el fin de seguir un enfoque metodológico personalizado y adaptado a las características del proyecto. Las prácticas utilizadas se detallan a continuación:

\begin{itemize}

	\item \textbf{Organización de las tareas en unidades de trabajo}. El trabajo a realizar para construir el \emph{proxy} inverso se ha divido en tareas menudas denominadas unidades de trabajo. Estas definen funcionalidades más pequeñas y concretas que los casos de uso y son más abstractas que las historias de usuario, ya que manifiestan de forma más clara la posibilidad de tratarse de tareas no solo relacionadas con cambiar el producto sino otras como crear la base de datos o renovar una suscripción de un servicio web.

	\item \textbf{Uso de un tablero \emph{Kanban}}. En relación con la anterior práctica ágil, las unidades de trabajo han sido gestionadas a través de un tablero \emph{Kanban} con tres columnas: \emph{TODO}, \emph{DOING}, \emph{DONE}. La única columna reseñable es la segunda, en la que primero se lleva a cabo una pequeña especificación de la unidad de trabajo en cuestión, principalmente definiendo sus pruebas de aceptación, y después, se implementa. Cabe destacar que el tablero utilizado es muy simple, sin embargo, podía haberse tratado de uno más complejo si el desarrollo se hubiera llevado a cabo en equipo con más personas, por ejemplo. La herramienta utilizada a modo de tablero \emph{Kanban} ha sido Trello \cite{Trello}.

	\item \textbf{Priorización de las unidades de trabajo}. Dentro de la propia columna \emph{TODO} del tablero \emph{Kanban}, las unidades de trabajo han estado ordenadas de mayor a menor prioridad en todo momento. Este almacén de trabajo priorizado a realizar se conoce como \emph{backlog} y ha permitido conocer con facilidad las unidades de trabajo que se debían abordar al terminar otras.

	\item \textbf{Definición de pruebas de aceptación}. Se ha utilizado este tipo de pruebas para especificar las unidades de trabajo correspondientes a la funcionalidad básica del \emph{proxy} inverso. Con ellas se establecen los límites de lo que se ha de considerar funcionamiento correcto o incorrecto. Además, algunas de las pruebas de aceptación han sido automatizadas, es decir, programadas dentro del propio proyecto, sistematizando y haciendo más fácil su ejecución. Se entrará más en detalle sobre las pruebas de aceptación definidas en el apartado \ref{pruebasDeAceptacion}.

	\item \textbf{Búsqueda de la sencillez y el minimalismo}. Se trata de no realizar esfuerzos innecesarios a la hora de implementar una determinada funcionalidad, esto es, buscar la solución más simple que cumpla los requisitos establecidos. De esta forma, se evita invertir tiempo en aspectos no definitivos o que se modificarán con posterioridad y que no afectan al funcionamiento inmediato del producto.

	\item \textbf{Afrontamiento y entrega de trabajo terminado de forma incremental}. Con el uso de unidades de trabajo se ha pretendido dividir y afrontar el trabajo a realizar mediante incrementos de funcionalidad, definidos precisamente por un conjunto de unidades de trabajo. Además, a medida que se ha terminado cada uno de estos incrementos, se ha entregado una nueva versión del producto. En este caso, las entregas del producto han correspondido con el despliegue de la determinada versión, quedando disponible para ser utilizada por el resto de la aplicación.

	\item \textbf{Ejecución de pruebas de regresión}. Han consistido en ejecutar las pruebas de aceptación de todas las unidades de trabajo finalizadas hasta la fecha cada vez que un incremento considerable de funcionalidad era terminado. Con estas se consigue asegurar el correcto funcionamiento del producto antes de cada nueva entrega o despliegue. Las pruebas de regresión llevadas a cabo en este proyecto se comentarán en el apartado \ref{pruebasDeRegresion}.

\end{itemize}

		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PLAN DE TRABAJO %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		\subsection{Plan de trabajo} \label{planDeTrabajo}

Tras la exposición de la metodología seguida para este proyecto, se va a detallar el plan de trabajo trazado. La elaboración del tablero \emph{Kanban} se ha tomado como punto de partida y se muestran sus unidades de trabajo iniciales en la figura \ref{kanbanInicial}, las cuales fueron obtenidas a partir de la especificación de requisitos del apartado \ref{especificacionRequisitos}. Cabe destacar que estas no han sido las definitivas y posteriormente se han modificado y creado nuevas, como es habitual en las metodologías ágiles.

\begin{figure}[ht]
\centering
\includegraphics[width=0.34\textwidth]{imagenes/backlogInicial}
\caption{\emph{Backlog} con las unidades de trabajo iniciales.}
	\label{kanbanInicial}
\end{figure}

Una vez elaborado y priorizado el \emph{backlog}, el plan de trabajo ha sido hacer uso del tablero \emph{Kanban} e ir desarrollando incrementos de funcionalidad poniendo en práctica las características ágiles comentadas en el punto anterior.

Por último, es interesante comentar el inicio particular de este desarrollo, pues se planificó la elaboración de dos prototipos de microservicio. Estos tendrían la misión de demostrar si el uso de código autogenerado a partir de modelos, como en el resto de microservicios, penaliza en exceso el rendimiento del \emph{proxy} inverso. Esto podía deberse al tratarse de un código menos específico y más genérico, así como al poseer un exceso de características innecesarias para el caso en cuestión pero que sí son adecuadas para el resto de microservicios.

Así pues, la construcción de los prototipos culminaría en una medición de tiempos para evaluar la eficiencia de las dos soluciones y la consiguiente elección para continuar con el desarrollo de uno u otro prototipo. Se comentarán más detalles de todo este proceso en el siguiente apartado.

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROGRAMACIÓN %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\section{Programación} \label{programacion}

La parte de programación del \emph{proxy} inverso que protagoniza este trabajo ha pasado por distintas etapas o fases que se van a comentar a continuación. Estas etapas han sido creadas para facilitar la comprensión del desarrollo y las funcionalidades añadidas al producto. De esta forma, las agrupan para comentarlas poco a poco junto con los problemas o dificultades encontradas a la hora de implementarlas.

		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CONSTRUCCIÓN DE PROTOTIPOS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		\subsection{Construcción de prototipos}

Como el plan de trabajo del punto \ref{planDeTrabajo} establece, el desarrollo comienza con la elaboración de dos prototipos de microservicio para evaluar la viabilidad de utilizar la estructura autogenerada de los demás microservicios sobre el \emph{proxy} inverso. De esta forma, se construyó un microservicio sin utilizar la generación de código y otro utilizándola para medir posteriormente las diferencias de rendimiento entre uno y otro. Por otro lado, cabe destacar que a los \emph{proxy} inversos que forman parte de una arquitectura de microservicios no se les suele dar tal categoría. Sin embargo, en este trabajo sí se le va a incluir dentro de los denominados microservicios debido a que se quiere que tenga la misma estructura, RNF04 del apartado \ref{requisitosNoFuncionales}. Al fin y al cabo es un tema simplemente de nomenclatura.

			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% MICROSERVICIO A MANO %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

			\subsubsection{Microservicio a mano}

El primero de los prototipos se hizo lo más simple posible, es decir, con la lógica justa y necesaria para desempeñar su trabajo y sin seguir ninguna arquitectura concreta. Esto último choca con el requisito no funcional comentado en el párrafo anterior pero se hizo para que las diferencias de rendimiento se evidenciaran más todavía, pues así se compararía un prototipo únicamente con el funcionamiento de \emph{proxy} inverso y otro con también una estructura con multitud de clases que pudiera penalizar el rendimiento.

Para la creación de este prototipo, primero fue necesario crear un proyecto desde cero y ubicarlo en el lugar correspondiente del directorio de carpetas de la aplicación, junto a los demás microservicios. Acto seguido, se añadió el funcionamiento de \emph{proxy} inverso dado por YARP (CU03 del apartado \ref{casosDeUso}) y se le crearon rutas de manera predefinida para hacer las primeras pruebas con peticiones Postman. Las rutas predefinidas se configuran en el archivo \emph{appsettings.json}. Estos dos últimos aspectos se comentan con más detalle en el apartado \ref{ejemploUsoYARP} y un ejemplo de configuración de rutas estáticas se puede ver en la figura \ref{ejemploYARP_appsettings}.

Después de realizar las tareas comentadas queda un proyecto muy simple pero totalmente funcional. Se muestra la solución de Visual Studio correspondiente en la figura \ref{prototipoMano}.

\begin{figure}[ht]
\centering
\includegraphics[width=0.5\textwidth]{imagenes/prototipoMano}
\caption{Solución de Visual Studio del prototipo de \emph{proxy} inverso hecho a mano.}
	\label{prototipoMano}
\end{figure}

			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% MICROSERVICIO AUTOGENERADO %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

			\subsubsection{Microservicio autogenerado}

Respecto al segundo prototipo, fue construido utilizando las mismas herramientas de generación automática de código con las que fueron construidos el resto de microservicios de la aplicación. Cabe destacar que, para no realizar esfuerzos en vano (práctica ágil comentada en el apartado \ref{metodologia}) sin saber qué prototipo iba a ser la opción elegida, se dejaron algunos detalles correspondientes a la generación de código pendientes. Esto se debe a que el proceso de generación de código no se adaptaba al cien por cien a las necesidades del nuevo microservicio, lo que suele ser habitual al crear microservicios con características diferentes.

Así pues, se creó de cero otro proyecto, ahora utilizando la generación automática de código a partir de modelos. Para ello fue necesario modelar una entidad \emph{Route} con los campos necesarios para identificar las rutas, esto es, la ruta base de las peticiones que se tiene que capturar y la dirección a la que redirigirlas. También se escribió el código correspondiente a YARP para crear el \emph{proxy} inverso y se configuraron algunas rutas por defecto. Por último, se crearon algunas consultas Postman para probar este prototipo. Estas tres últimas acciones son las mismas que para el caso del microservicio manual, con algunas diferencias para adaptarse a la solución concreta.

El microservicio autogenerado resultante se muestra en la figura \ref{prototipoAutogenerado}. Es interesante comparar esta solución con la del prototipo hecho a mano para comprobar que la complejidad y cantidad de proyectos de Visual Studio, y por consiguiente también de clases, es muchísimo mayor en este caso. Cabe resaltar que faltarían los proyectos correspondientes a la capa de dominio y contratos, los cuales se encuentran en una solución aparte y no es necesario mostrarlos para realizar esta comparativa puesto que las evidencias comentadas son suficientes.

\begin{figure}[ht]
\centering
\includegraphics[width=0.45\textwidth]{imagenes/prototipoAutogenerado}
\caption{Solución de Visual Studio del prototipo de \emph{proxy} inverso hecho con generación de código.}
	\label{prototipoAutogenerado}
\end{figure}

			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% COMPARATIVA %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

			\subsubsection{Comparativa}

Una vez construidos los prototipos, se procedió a medir el impacto de seguir la norma para decidir qué prototipo desechar y con cuál seguir adelante. Para ello, se creó una aplicación de consola muy simple que se encargara de probar los dos microservicios de \emph{proxy} inverso creados. Esta lanzaba un número determinado de veces la misma petición sobre el \emph{proxy} inverso que se le indicara para que este la redirigiera y calcular así el tiempo medio de respuesta. La figura \ref{medidorTiempos} muestra su código principal, el cual era ejecutado una vez por cada prototipo.

\begin{figure}[ht]
\centering
\includegraphics[scale=1]{imagenes/medidorTiempos}
\caption{Código principal de la aplicación de consola para medir los tiempos del enrutamiento de los dos prototipos.}
	\label{medidorTiempos}
\end{figure}

Es importante destacar que las acciones de añadir y eliminar rutas dinámicamente, todavía por implementar, no son relevantes en esta comparativa ya que se llevan a cabo muy pocas veces en relación con el enrutamiento, es decir, no son las más comunes. Por este motivo, no se ha creído conveniente medirlas y han sido implementadas con posterioridad.

Por otro lado, es interesante comentar por qué desde un primer momento se enfocaba la comparativa como una prueba para ver si el microservicio autogenerado era viable y, por tanto, preferible sobre el otro. Uno de los motivos era que, si se utilizaba la generación de código, el \emph{proxy} inverso se podría desplegar con el mismo procedimiento que estaba pensado para el resto de microservicios, lo que evitaría tener que crear un mecanismo especial para él y permitiría conservar esa homogeneidad para simplificar los despliegues. Otro motivo se trataba de la trivialidad para hacer cualquier cambio de estructura, pues la generación de código lo haría de forma automática. Por el contrario, habría que hacerlo manualmente en el microservicio a mano para continuar con el cumplimiento del requisito no funcional RNF04, del apartado \ref{requisitosNoFuncionales}.

Los resultados de las mediciones fueron claros: ambos prototipos tenían un rendimiento casi idéntico.
En concreto, para 10000 iteraciones se obtuvieron tiempos medios de respuesta de 3,6 milisegundos para el prototipo a mano y de 3,7 para el autogenerado. Se realizaron pruebas con diferente número de iteraciones pero los resultados no variaron en demasía. Con esto se concluye que utilizar el segundo prototipo supone una penalización de tiempo de no llega al 3\%. Esto se consideró despreciable e insuficiente para contrarrestar las ventajas comentadas por lo que se decidió eliminar el primer prototipo y continuar así con la versión autogenerada.

		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CONSOLIDACIÓN DEL MICROSERVICIO AUTOGENERADO %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		\subsection{Consolidación del microservicio autogenerado}

Una vez elegida la opción de seguir el estándar de microservicio de la aplicación, hubo que resolver los aspectos de la generación de código que no quedaron ajustados. Así pues, se tuvieron que modificar algunas plantillas de código a partir de las cuales se generan las clases y proyectos que forman los microservicios.

Un ejemplo de problemas con la generación de código fue el método \emph{Configure} de la clase \emph{Startup}. Este tenía que ser modificado para añadir la llamada \emph{endpoint.MapReverseProxy()} pero la generación de código no lo permitía, no pudiéndose personalizar este método en función del microservicio en cuestión. De esta forma, la modificación de las plantillas consistió en generar una llamada a un método estático dentro de ese \emph{Configure}, que se implementaría en una clase parcial. La figura \ref{startup} muestra cómo queda la clase \emph{Startup}.

% TODO: Solucionar problema visualización fotos

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{imagenes/startup}
\end{figure}
\begin{figure}[ht]
\centering
\includegraphics[width=0.96\textwidth]{imagenes/startupParcial}
\caption{Clase parcial \emph{Startup} del \emph{proxy} inverso.}
	\label{startup}
\end{figure}

Después de terminar los flecos de generación de código, era momento de seguir añadiendo funcionalidad. De este modo, se modelaron e implementaron las acciones de añadir y eliminar rutas dinámicamente, correspondientes a los casos de uso CU01 y CU02 del apartado \ref{casosDeUso}. También fueron probadas con las correspondientes peticiones Postman.

Por otro lado, se añadió un mecanismo de autenticación de peticiones, tal y como demanda el requisito no funcional RNF01 de la sección \ref{requisitosNoFuncionales}. Este consistió simplemente en utilizar el mismo mecanismo de seguridad que se utiliza en el resto de microservicios, el cual utiliza el sistema de autenticación que ofrece .NET y se genera de manera automática para las acciones modeladas, como es el caso de las dos acciones comentadas en el párrafo anterior. Solo sería necesario indicar a YARP que utilizase dicho mecanismo también a la hora de enrutar peticiones.

También se creyó conveniente estandarizar el tratamiento de las rutas base de las peticiones que representan una ruta. Esto se hizo para hacer el \emph{proxy} inverso más robusto y evitar posibles malentendidos con YARP, pues espera recibir las rutas de una manera concreta y no otra. Por ejemplo, requiere que se utilicen barras como separadores de ruta en lugar de barras invertidas. Para ello se creó un método \emph{GetYarpNormalizedPath}, en la clase \emph{RoutesUtils}, que normaliza una ruta dada según el esquema que YARP acepta. El método en cuestión se muestra en la figura \ref{getYarpNormalizedPath} y hace cosas como forzar el uso de las barras como separadores o añadir el patrón '\emph{\{*remainder\}}' para capturar todas las peticiones con rutas que empiecen con el prefijo indicado independientemente de como sigan.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{imagenes/getYarpNormalizedPath}
\caption{Método \emph{GetYarpNormalizedPath}.}
	\label{getYarpNormalizedPath}
\end{figure}

Además, se consideró oportuno automatizar algunas de las pruebas de aceptación de las acciones de añadir y eliminar rutas y para el método \emph{GetYarpNormalizedPath}, recién comentado en el párrafo anterior. Se entrará más en detalle acerca de estas pruebas en el apartado de pruebas \ref{pruebas}.

Por último, se incluyó el \emph{proxy} inverso en el núcleo de microservicios principales llamados Core. Estos son los que se despliegan en primer lugar ya que son utilizados por todos los demás, o al menos por la mayoría. Se ahondará en este aspecto de los despliegues en el siguiente apartado. Microservicios de este tipo son los que se encargan de aspectos clave tales como la seguridad, el despliegue de la aplicación o, como es el caso de este, la comunicación entre los microservicios.

		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PRIMEROS DESPLIEGUES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		\subsection{Primeros despliegues}

A estas alturas del desarrollo ya se tenía una primera versión del \emph{proxy} inverso perfectamente funcional pero antes de llevar a cabo los primeros despliegues había que hacer algunas modificaciones para que la interfaz de usuario y los microservicios lo utilizaran. Derivado de estos despliegues se presentaron algunos problemas que también serán comentados.

			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% SISTEMAS DE DESPLIEGUE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

			\subsubsection{Sistema de despliegue}

Primero de todo, se va a explicar como se realizan los despliegues de la aplicación. Como se ha comentado de pasada en varios puntos de esta memoria, la aplicación sobre la cual se trabaja tiene un microservicio especial encargado de orquestar los despliegues. La cuestión es que no está del todo operativo todavía, pues la aplicación se encuentra en desarrollo, y por este motivo se realizan dos tipos de despliegue:

\begin{itemize}

	\item El primero de ellos consiste en desplegar los microservicios en contenedores Docker \cite{Docker}. Se trata de una manera de poder realizar despliegues antes de que el microservicio específico esté terminado. Permite así hacer pruebas con el resto y ver como se comportan.

	\item El segundo es el que lleva a cabo el microservicio pensado para ello. A grandes rasgos, este ordena y organiza los servidores preparados para correr la aplicación y les dice a cada uno qué microservicio o microservicios tiene que ejecutar. Por el momento, los microservicios que despliega no se utilizan porque se encuentra en fase de pruebas.

\end{itemize}

Una vez expuestos los modos de despliegue y el por qué de su coexistencia, cabe resaltar que el \emph{proxy} inverso se ve obligado a ser capaz de trabajar con ambos. No obstante, en un futuro desaparecerá el primero de ellos y el segundo será el que se emplee de manera definitiva.

			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% INTERFAZ DE USUARIO %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

			\subsubsection{Interfaz de usuario}

Para empezar con los despliegues, se decidió hacer que solo la interfaz de usuario utilizara el \emph{proxy} inverso para no romper toda la aplicación en caso de fallar. Cabe destacar que, como la aplicación se encontraba todavía en fase de desarrollo, no hubiera sido un gran problema si la interfaz de usuario quedara inutilizable por un breve periodo de tiempo por culpa del nuevo microservicio. Sin embargo, la caída del \emph{backend} podría haber supuesto algún inconveniente para el resto del equipo de la aplicación puesto que no sería posible hacer pruebas sobre los microservicios desplegados. De esta manera, se pretendía minimizar riesgos.

Además, como paso previo a incluir el \emph{proxy} inverso al proceso de despliegue, también se hicieron pruebas de manera local para comprobar que todo funcionaba correctamente y que la interfaz de usuario no se iba a quedar caída. Se desplegó el \emph{proxy} inverso en una máquina a parte y se le cargó de rutas que apuntaban a los microservicios ya desplegados para que la interfaz de usuario lo utilizara. Se hicieron peticiones desde dicha interfaz de usuario y no hubo problemas.

La interfaz de usuario de la aplicación se conectaba directamente a los microservicios por lo que hizo falta interponer el nuevo componente entre ella y el \emph{backend}. Para ello, fue necesario modificar las direcciones a las que apuntaba, en concreto, substituir las de cada microservicio por la del \emph{proxy} inverso. De esta forma, la interfaz de usuario dejaba de conocer todos los microservicios para solo conocer su dirección.

No obstante, las direcciones de los microservicios ahora debían ser conocidas por el \emph{proxy} inverso, por lo que hubo que cargárselas. Aquí es donde entran en juego los diferentes modos de despliegue. Para los despliegues con el microservicio específico, esté es quien tiene que cargar de rutas el \emph{proxy} inverso cada vez que le ordene a un servidor ejecutar un determinado microservicio. Con respecto al despliegue en Docker, las rutas han de ser cargadas de una manera predefinida. Para especificar dichas rutas, se ha creado un fichero llamado \emph{defaultRoutes.json} (figura \ref{defaultRoutes}), que es leído al iniciarse el \emph{proxy} inverso y las rutas que describe son añadidas.

\begin{figure}[ht]
\centering
\includegraphics[width=0.6\textwidth]{imagenes/defaultRoutes}
\caption{Fichero \emph{defaultRoutes.json}.}
	\label{defaultRoutes}
\end{figure}

			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% MICROSERVICIOS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

			\subsubsection{Microservicios}

Una vez la interfaz de usuario funcionaba correctamente con el \emph{proxy} inverso desplegado, se hizo que los propios microservicios lo utilizaran para comunicarse entre ellos. Igual que en el caso anterior, también fue necesario cambiar las direcciones a las que apuntaban los microservicios, ahora pasarían a conocer solo al \emph{proxy} inverso.

Por otro lado, una vez más hay que diferenciar los cambios para los dos modos de despliegue. Al respecto del de Docker, también se añadieron al \emph{defaultRoutes.json} las rutas que fueron necesarias, correspondientes a algunos microservicios que no son utilizados por la interfaz de usuario. En referencia al segundo, se mejoró la manera en la que el microservicio de despliegue añadía rutas al \emph{proxy} inverso.

Como modificación común para los dos modos, se tuvo que repensar el orden de despliegue de los microservicios. Estos, cuando son levantados, intentan contactar con sus dependencias y fallan si no las encuentran vivas. Por este motivo, el \emph{proxy} inverso debe estar en marcha cuando esta especie de saludos se lleven a cabo. El problema es que él también depende de otros microservicios, creando así un círculo de dependencias. La solución por la que se apostó fue levantar a la vez los microservicios que se entrelazan en este círculo utilizando reintentos en todas sus llamadas.

			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROBLEMAS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

			\subsubsection{Problemas}

El problema más grande que surgió a raíz de los primeros despliegues fue con unos \emph{timeouts}. Resulta que dos microservicios concretos realizaban determinadas peticiones con un \emph{timeout} muy grande debido al elevado coste de las mismas y por algún motivo dichas peticiones no se completaban satisfactoriamente al pasar por el \emph{proxy} inverso. El código de estado de error que tenían era el 504, correspondiente al mensaje en inglés '\emph{Gateway timeout}'. Parecía que el \emph{proxy} inverso cortaba las llamadas antes de que terminaran. Para solucionarlo momentáneamente y no dejar caídos esos microservicios, se optó por hacer que ellos y solo ellos no lo utilizaran hasta que el problema fuera analizado en detalle.

El problema recién expuesto fue estudiado a fondo más tarde y al final resultó ser culpa de YARP, que utiliza un timeout por defecto de 100 segundos para redirigir peticiones. La solución fue aumentarlo para las rutas correspondientes a las peticiones que se redirigen hacia los microservicios en cuestión. Para ello, fue necesario modelar y añadir un parámetro opcional para el \emph{timeout} en la creación de las rutas. De esta forma se permite su personalización en función de la ruta que se utilice.

La solución dada al problema puede parecer que no es la óptima ya que cualquier petición relacionada con una ruta de \emph{timeout} grande podría durar más de lo esperado, es decir, el aumento del \emph{timeout} afecta a todas las peticiones que se emparejan con esa ruta, siendo no del todo correcto. Una posible mejora sería crear rutas específicas con \emph{timeouts} grandes para solo las peticiones que lo necesiten. No obstante, no se cree necesario complicar el funcionamiento de esa manera ya que, en la práctica, el comportamiento del \emph{proxy} inverso no variaría demasiado. Además, si un cliente con un determinado \emph{timeout} realiza una petición a través del \emph{proxy} inverso y la ruta correspondiente tiene uno mayor, el que prevalecerá será el del cliente y el del \emph{proxy} inverso no tendrá efecto. De esta manera, solo sirve de límite en caso de que el del \emph{proxy} inverso sea menor.

		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PRODUCTO FINAL %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		\subsection{Producto final}

En esta etapa final se hicieron algunos retoques y se implementaron algunas funcionalidades más que se pasan a detallar.

			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PERSONALIZACIÓN DE LOS MENSAJES DE LOG %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

			\subsubsection{Personalización de los mensajes de log}

Una de las mejoras que se llevó a cabo fue personalizar los mensajes de \emph{log} para mostrar más información acerca de las peticiones enrutadas. YARP ya muestra mensajes pero se consideraba interesante añadir la fecha y hora en la que se produjo y el código de estado resultante de la petición. De esta manera, se facilitaría la labor de encontrar posibles errores derivados del enrutamiento de peticiones tales como el de los \emph{timeouts}. Para ello, fue necesario crear y añadir un \emph{middleware} nuevo a la \emph{pipeline} de YARP, explicada en el apartado \ref{pipelineYARP}. El \emph{middleware} creado ha sido llamado \emph{CustomProxyLog} y la figura \ref{logs} muestra los mensajes por defecto de YARP y los personalizados a través de este \emph{middleware} para ver las diferencias y el resultado final.

\begin{figure}[ht]
\centering
\includegraphics[width=0.9\textwidth]{imagenes/logsYARP}
\end{figure}
\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{imagenes/logs}
\caption{Mensajes de \emph{log} por defecto de YARP y personalizados.}
	\label{logs}
\end{figure}

			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% MULTIINSTANCIA DE MICROSERVICIOS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

			\subsubsection{Multiinstancia de microservicios}

Una de las funcionalidades más importantes añadidas en esta etapa ha sido permitir la multiinstancia de microservicios. Esta consiste en soportar la coexistencia de varias instancias de un mismo microservicio de forma que las mismas peticiones puedan ser enrutadas a diferentes direcciones. De esta forma se permite tener más de un recurso atendiendo determinadas peticiones, si se necesita. Relacionado con esto, se permite también realizar balanceo de carga entre las diferentes instancias de un mismo microservicio.

Para llevar a cabo esta modificación fue necesario primero mejorar el sistema de creación de identificadores. YARP utiliza tres entidades para configurar rutas: \emph{Route}, \emph{Cluster} y \emph{Destination}. No es relevante entrar en mucho más detalle del funcionamiento interno pero sí comentar que las entidades de estos tipos necesitan un identificador único. Este se construía cuando se añadían rutas y de manera un poco rudimentaria por lo que hubo que hacer algo al respecto. La solución fue sistematizar su creación utilizando los parámetros de entrada y asegurando que no se pudieran repetir. Además, era importante que la forma de crearlos fuera idempotente, es decir, que siempre se obtuviera el mismo resultado para los mismos parámetros de entrada. Los métodos encargados de esto se encuentran en la clase \emph{RoutesUtils} y se muestran en la figura \ref{creacionIdentificadores}.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{imagenes/creacionIdentificadores}
\caption{Métodos encargados de crear los identificadores de las entidades de YARP.}
	\label{creacionIdentificadores}
\end{figure}

De una manera similar, las acciones de añadir y eliminar rutas fueron modificadas para jugar con los tres tipos de entidades de YARP. Un ejemplo del tratamiento que requieren puede ser el hecho de que un \emph{Cluster} tiene una o más \emph{Destinations}, por lo que no tendrá que ser creado si ya existe cuando se añade una nueva destinación. Todo esto sería trivial si se utilizara el mecanismo de carga estático pero, como se ha comentado en varias ocasiones a lo largo de este memoria, no encaja con el contexto de este \emph{proxy} inverso.

Por otro lado, YARP ofrece diferentes algoritmos de balanceo de carga: \emph{First}, \emph{Random}, \emph{RoundRobin}, \emph{LeastRequests} y \emph{PowerOfTwoChoices}. Se ha utilizado el último de ellos, el cual selecciona dos destinaciones aleatorias y elige la que menos peticiones esté atendiendo. Esta política intenta evitar la sobrecarga de buscar la dirección que está atendiendo menos peticiones y el caso peor de elegir de manera aleatoria una que esté muy ocupada.

Por último, las peticiones Postman se modificaron para hacer pruebas, así como las pruebas de aceptación automatizadas tuvieron que ser adaptadas e incluso se crearon algunas nuevas.

			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% SEGUNDO NIVEL DE REDIRECCIÓN %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

			\subsubsection{Segundo nivel de redirección}

Otra funcionalidad de peso es el segundo nivel de redirección. Se trata de tener un \emph{proxy} inverso en cada servidor que ejecuta alguna parte de la aplicación con la motivación de no exponer un puerto por cada microservicio. De esta forma, todas las peticiones se mandan al \emph{proxy} inverso del servidor en cuestión y este las redirige a los microservicios que corre. Esto desemboca en un esquema de dos niveles como el que se muestra en la figura \ref{esquemaProxyInversoDoble}, en el que entran en juego un \emph{proxy} inverso general y los concretos de cada servidor.

\begin{figure}[ht]
\centering
\includegraphics[width=0.9\textwidth]{imagenes/esquemaProxyInversoDoble}
\caption{Esquema de dos niveles de \emph{proxy} inverso.}
	\label{esquemaProxyInversoDoble}
\end{figure}

Para implementar esta característica se plantearon varias opciones. Primero se decidió utilizar YARP también en el código de los servidores que ejecutan los microservicios pero, al poco tiempo de empezar, se encontraron problemas y aspectos que no terminaban de cuadrar con lo que se buscaba. El más importante de ellos era el hecho de tener que mantener el código que envuelve la infraestructura de YARP en dos lugares diferentes. Para evitarlo, finalmente se optó por hacer que cada servidor ejecutara un \emph{proxy} inverso como si se tratara de un microservicio más. Es momento entonces de darse cuenta de que la elección del prototipo autogenerado fue la correcta, pues ahora permite realizar esto de una manera sencilla. También fue necesario modificar el código que carga el \emph{proxy} inverso de rutas para hacer lo propio con todos los \emph{proxy} inversos.

			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% FILTRO MISMA MÁQUINA %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

			\subsubsection{Filtro misma máquina}

Otro \emph{middleware} creado es el llamado \emph{SameMachineFilter}. Surge de las dos nuevas funcionalidades anteriores y trata de mejorar el sistema de enrutamiento disminuyendo el tiempo de algunas peticiones. Se encarga de comprobar si existe una destinación a la que redirigir las peticiones en la misma máquina que se encuentra el \emph{proxy} inverso y, si es el caso, enrutarlas hacia ella en lugar de hacia otra para evitar que la petición salga de la máquina y tarde más tiempo en finalizar.

			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROBLEMA PETICIONES PESADAS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

			\subsubsection{Problema peticiones pesadas}

De la misma manera que se encontró un fallo del \emph{proxy} inverso correspondiente a las peticiones con \emph{timeouts} grandes gracias a los despliegues progresivos que se han ido realizando, también se descubrió otra deficiencia relacionada con las peticiones que pesaban mucho, es decir, las que tenían un cuerpo muy grande. En este caso la petición problemática devolvía un código de estado 400, error general del lado del cliente.

Es interesante resaltar que la petición que produjo el fallo no podía ser reproducida ya que era fruto de la interacción múltiple entre varios microservicios. Además, el código de estado de error era mucho menos descriptivo que en el otro problema, un 400 genérico que no aportaba casi información. Tras mucho tiempo de investigaciones se llegó a la conclusión de que la única posibilidad era que tratase de una petición demasiado pesada. De esta forma, se intentó reproducir el mensaje de error con una petición Postman con un cuerpo muy grande y, ¡tachán!, problema encontrado. Sin embargo, faltaba averiguar cómo indicar a YARP que dejara de tener ese comportamiento o, al menos, aumentar el peso máximo de las peticiones.

La documentación oficial no decía nada al respecto por lo que se dedujo, después de unas cuantas pruebas, que YARP utilizaba la configuración de Kestrel \cite{Kestrel} para establecer el máximo peso que puede tener una petición. Kestrel no es más que el servidor web que utilizan por debajo las aplicaciones de .NET y, por consiguiente, YARP. De esta forma, se eliminó el límite máximo de peso para las peticiones de la manera que muestra la figura \ref{configuracionKestrel}, en el método \emph{CreateHostBuilder} de la clase \emph{Program}. Con esta solución, los microservicios destino de los enrutamientos serían quienes establecerían el peso máximo.

\begin{figure}[ht]
\centering
\includegraphics[width=0.9\textwidth]{imagenes/configuracionKestrel}
\caption{Esquema de dos niveles de \emph{proxy} inverso.}
	\label{configuracionKestrel}
\end{figure}

			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% RECORRIDO PETICIONES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

			\subsubsection{Recorrido peticiones}

Una vez comentadas todas la funcionalidades del producto desarrollado se quiere mostrar un esquema (figura \ref{esquemaInteraccionProxyInverso}) del recorrido completo de una petición que proviene de la interfaz de usuario y que pasa por varios microservicios. De esta forma, se pretende ilustrar la función del \emph{proxy} inverso y cómo el resto de componentes de la aplicación interactúa con él. Entrando en detalle, la interfaz de usuario realiza una petición al microservicio 1 y para ello primero pasa por el \emph{proxy} inverso general y después por el concreto del servidor que contiene el microservicio en cuestión. Para poder responder, el microservicio 1 necesita hacer una petición al A y este, a su vez, al Z. Una vez terminadas estas peticiones anidadas, la respuesta le llega al microservicio 1 y este devuelve a la interfaz la respuesta a la petición primera. Para finalizar, es interesante resaltar el uso de los \emph{proxy} inversos tanto para las peticiones de la interfaz de usuario como para las que se realizan entre microservicios, es decir, nadie se comunica con nadie sin pasar por alguno de ellos.

\begin{figure}[ht]
\centering
\includegraphics[width=0.9\textwidth]{imagenes/esquemaInteraccionProxyInverso}
\caption{Esquema de interacción entre el \emph{proxy} inverso y el resto de componentes de la aplicación al procesar una petición de la interfaz de usuario.}
	\label{esquemaInteraccionProxyInverso}
\end{figure}

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PRUEBAS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\section{Pruebas} \label{pruebas}

Primero de todo, es interesante destacar que los despliegues comentados en el apartado de programación anterior (\ref{programacion}) se pueden considerar pruebas. En ellos se introduce el \emph{proxy} inverso en el entorno en el que finalmente va a trabajar para ver cómo responde a medida que se le añaden funcionalidades. Se trata, sin duda, de pruebas que pretenden observar el comportamiento del producto \emph{software} y ver si ocurre algún fallo o problema. Como han sido detallados en dicho apartado no cabe mencionar gran cosa más acerca de ellos, simplemente enfatizar que sirvieron para descubrir pequeños errores tales como el de los \emph{timeouts} grandes o el de las peticiones pesadas. Ambos hacían que las peticiones enrutadas no terminaran correctamente y gracias a estas pruebas se pudieron solucionar antes de dar por finalizado el proyecto.

Estas pruebas realizadas durante el desarrollo tienen un porqué. Este es el hecho de querer seguir la práctica ágil de entregas continuas, comentada en la sección \ref{metodologia}, con el fin de obtener \emph{feedback} continuo acerca del grado de corrección del \emph{proxy} inverso sobre lo que se espera de él. De esta forma, se ha considerado imprescindible no dejar las pruebas para el final, puesto que se trata de un componente clave en la arquitectura de la aplicación de la que forma parte.

Desde una perspectiva diferente a las pruebas de puesta en funcionamiento real recién descritas, se han llevado a cabo otro tipo de ellas para comprobar el correcto funcionamiento del \emph{proxy} inverso: pruebas de aceptación y pruebas de regresión. De la misma manera, han sido ejecutadas durante el desarrollo en lugar de al final de este y serán comentadas con más detalle a continuación. También es conveniente resaltar se ha utilizado consultas Postman para realizar algunas de las pruebas, por lo que estas han sido actualizadas y se ha ido creando otras a medida que se han añadido nuevas características.

		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PRUEBAS DE ACEPTACIÓN %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		\subsection{Pruebas de aceptación} \label{pruebasDeAceptacion}

Recordando lo comentado en el apartado \ref{metodologia}, se han definido pruebas de aceptación (PAs) para especificar muchas de las unidades de trabajo que representan el trabajo a realizar. Estas determinan el buen o mal funcionamiento de la característica descrita por la unidad de trabajo en cuestión por lo que se utilizan para comprobar si esta se ha implementado correctamente.

Una unidad de trabajo no se considera terminada hasta que no pasa satisfactoriamente las pruebas de aceptación que tiene asignadas. Así pues, las pruebas de aceptación han sido ejecutadas cuando se ha creído que la unidad de trabajo a la cual hacen referencia ha estado correctamente implementada y como paso previo a incluirla en el grupo de las terminadas. En caso de no obtener un resultado positivo, estas se pasaban de nuevo una vez corregido el problema, pudiéndose repetir este proceso más de una vez.

A continuación, se va a mostrar una parte de las pruebas de aceptación elaboradas partiendo del nombre de la unidad de trabajo que prueban. Cabe destacar que, además, se han automatizado algunas de las más importantes para facilitar así su ejecución. Se enseñará también el código de alguna de ellas.

			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% DEFINICIÓN DE ALGUNAS PAs %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

			\subsubsection{Definición de algunas PAs}

Las figuras \ref{PAsAñadirRutasDinamicamente}, \ref{PAsNormalizarRutaBasePeticiones}, \ref{PAsEnrutamiento}, \ref{PAsPersonalizacionTimeouts} y \ref{PAsMultiinstanciaDeMicroservicios} son capturas de pantalla de las pruebas de aceptación de cuatro unidades de trabajo. Para cada PA se indica un nombre que la identifica, un primer punto con la acción o acciones que hay que llevar a cabo para ejecutarla y otro punto con el resultado esperado.

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\textwidth]{imagenes/PAsAñadirRutasDinamicamente}
\caption{Pruebas de aceptación de la unidad de trabajo 'Añadir rutas dinámicamente'.}
	\label{PAsAñadirRutasDinamicamente}
\end{figure}

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\textwidth]{imagenes/PAsNormalizarRutaBasePeticiones}
\caption{Pruebas de aceptación de la unidad de trabajo 'Normalizar rutas base peticiones'.}
	\label{PAsNormalizarRutaBasePeticiones}
\end{figure}

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\textwidth]{imagenes/PAsEnrutamiento}
\caption{Pruebas de aceptación de la unidad de trabajo 'Enrutamiento'.}
	\label{PAsEnrutamiento}
\end{figure}

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\textwidth]{imagenes/PAsPersonalizacionTimeouts}
\caption{Pruebas de aceptación de la unidad de trabajo 'Personalización timeouts'.}
	\label{PAsPersonalizacionTimeouts}
\end{figure}

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\textwidth]{imagenes/PAsMultiinstanciaDeMicroservicios}
\caption{Pruebas de aceptación de la unidad de trabajo 'Multiinstancia de microservicios'.}
	\label{PAsMultiinstanciaDeMicroservicios}
\end{figure}

			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PRUEBAS AUTOMATIZADAS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

			\subsubsection{Pruebas automatizadas}

Las figuras \ref{testAñadirRutas}, \ref{testGetYarpNormalizedRequestsBasePath} y \ref{testsEnrutamiento} muestran el código de algunas de las pruebas de aceptación automatizadas. Es interesante mencionar que corresponden a PAs cuyas descripciones se han enseñado en la sección anterior, figuras \ref{PAsAñadirRutasDinamicamente}, \ref{PAsNormalizarRutaBasePeticiones} y \ref{PAsEnrutamiento} en concreto.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{imagenes/testAñadirRutas}
\caption{Prueba de aceptación automatizada de la unidad de trabajo 'Añadir rutas dinámicamente'.}
	\label{testAñadirRutas}
\end{figure}

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{imagenes/testGetYarpNormalizedRequestsBasePath}
\caption{Pruebas de aceptación automatizadas de la unidad de trabajo 'Normalizar rutas base peticiones'.}
	\label{testGetYarpNormalizedRequestsBasePath}
\end{figure}

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{imagenes/testsEnrutamiento}
\caption{Pruebas de aceptación automatizadas de la unidad de trabajo 'Enrutamiento'.}
	\label{testsEnrutamiento}
\end{figure}

		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PRUEBAS DE REGRESIÓN %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		\subsection{Pruebas de regresión} \label{pruebasDeRegresion}

Las pruebas de regresión son pruebas que se realizan sobre un producto \emph{software} anteriormente probado al que se le han hecho modificaciones. Con ellas se pretende asegurarse de que no se han introducido defectos que puedan producir errores sobre las funcionalidades implementadas previamente. 

En el caso del \emph{proxy} inverso, han consistido en ejecutar todas las pruebas de aceptación de las unidades de trabajo ya terminadas. Se han ejecutado antes de cada despliegue y con ellas se ha verificado el correcto funcionamiento de todas las características del producto de cara a que los despliegues no hicieran fallar el \emph{proxy} inverso ni cualquier otro componente de la aplicación. De esta forma, con estas pruebas se ha pretendido evitar todo tipo de problemas que pudieran entorpecer a los demás miembros del equipo de desarrollo de la aplicación ya que, si el \emph{proxy} inverso quedara caído durante un tiempo, el resto de microservicios y la interfaz de usuario no podrían contactar con nadie y caerían también. Es por esto que se han considerado un seguro de vida para garantizar, en cierta medida, que los despliegues serían un éxito.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CONCLUSIONES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Conclusiones}

Decir si los objetivos se han cumplido. Valorar el cumplimiento de los casos de uso y de los requisitos.

En un futuro se puede querer extender la funcionalidad y construir encima un API \emph{Gateway} que ofrezca agregaciones de peticiones o tareas transversales tales como monitorización de tiempos de las peticiones.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% BIBLIOGRAFÍA %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{thebibliography}{10}

\bibitem{LewisAndFowler}
Artículo de J. Lewis y M. Fowler acerca de los microservicios.
\newblock Disponible en:\\
\url{https://martinfowler.com/articles/microservices.html}

\bibitem{Newman}
Libro de referencia sobre microservicios:\\
\newblock Sam Newman,
\newblock \emph{Building Microservices.}
\newblock ISBN: 9781491950357

\bibitem{NGINX}
¿Cómo utilizar NGINX como proxy inverso?:\\
\url{https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy}

\bibitem{Apache}
¿Cómo utilizar Apache HTTPD como proxy inverso?:\\
\url{https://httpd.apache.org/docs/trunk/es/howto/reverse_proxy.html}

\bibitem{YARP}
Sitio oficial de YARP:\\
\url{https://microsoft.github.io/reverse-proxy}

\bibitem{Microsoft}
Sitio oficial de Microsoft:\\
\url{https://www.microsoft.com/es-es}

\bibitem{MiddlewaresPipeline}
Documentación de Microsoft acerca del método \emph{Configure} y de la \emph{pipeline} de \emph{middlewares}:\\
\url{https://docs.microsoft.com/es-es/aspnet/core/fundamentals/startup?view=aspnetcore-5.0#the-configure-method}

\bibitem{Ocelot}
Sitio oficial de Ocelot:\\
\url{https://threemammals.com/ocelot}

\bibitem{Postman}
Sitio oficial de Postman:\\
\url{https://www.postman.com}

\bibitem{NuGet}
Documentación de Microsoft acerca de los paquetes NuGet:\\
\url{https://docs.microsoft.com/es-es/nuget/quickstart/install-and-use-a-package-in-visual-studio}

\bibitem{ISO25010}
ISO/IEC 25010 (SQuaRE):\\
\url{https://iso25000.com/index.php/normas-iso-25000/iso-25010}

\bibitem{Trello}
Sitio oficial de Trello:\\
\url{https://trello.com}

\bibitem{Docker}
Sitio oficial de Docker:\\
\url{https://www.docker.com}

\bibitem{Kestrel}
Documentación de Microsoft acerca de Kestrel:\\
\url{https://docs.microsoft.com/es-es/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-5.0}

\end{thebibliography}

\end{document}
